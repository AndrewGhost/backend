1. 为什么协程比线程更加轻量级？

​      多个线程存在调度，把执行的权利从一个线程转移到另一个线程，原生线程的开销主要表现在：

​       **a. cpu在上下文切换中的开销**

​       **b. 线程的栈空间**

​    每次上下文切换都需要把前一个任务的cpu上下文，即cpu寄存器和程序计数器保存起来，然后加载新任务的相应寄存器和程序计数器，跳到程序计数器所指的位置，运行新任务。单次上下文切换在微秒级，假设只有10微秒，一秒钟也只能切换10万次。但是goroutine却可以达到上百万，上千万，因为它采用的是P，M， G的调度模型，这个不需要上下文切换。

​     P，golang运行时的线程，负责执行goroutine

​     M, 内核线程，每个P对应一个内核线程，goroutine在P的队列中等待执行。当一个G执行完成后，sched调度另一个G到P上执行，因此没有操作系统层面的上下文切换。

​        

​     原生linux线程会分配固定大小的栈空间，通过ulimit -as | grep stack查看，默认8MB。这样以来，8GB的内存只能同时容纳1024个线程。

​    而golang通过初始分配小空间，按需增加的方式实现巨量gorouting协程。

​     

​     因而，协程比线程更加轻量级。

